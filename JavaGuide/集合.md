### <img src="%E9%9B%86%E5%90%88.assets/Screen%20Shot%202023-08-13%20at%2011.32.51%20PM.png" alt="Screen Shot 2023-08-13 at 11.32.51 PM" style="zoom:33%;" />

### `List` & `Set`

- **`List`系列集合：添加的元素是有序、可重复、有索引的**
  - **有序：存 & 取 的顺序是一样的**
  - **有索引：可以通过索引获取元素**
- **`Set`系列集合：添加的元素是无序、不重复、无索引的**



### `ArrayList` 与 `LinkedList` 的区别

+ **数据结构：**
  + **`ArrayList` 底层是使用动态数组实现的**
  + **`LinkedList` 底层是使用双向链表实现的**
+ **效率：**
  + **`ArrayList`按照下标查询的时问复杂度O(1) (内存是连续的，根据寻址公式)，`LinkedList`不支持下标查询**
  + **查找（未知索引）：`ArrayList`和`LinkedList`都需要遍历，时间复杂度都是O(n）**
  + **新增和删除：**
    + **`ArrayList`尾部插入和删除，时间复杂度是O(1)；其他部分增删需要挪动数组，时间复杂度是O(n)**
    + **`LinkedList`头尾节点增删时间复杂度是O(1)，其他都需要遍历链表，时间复杂度是O(n）**

+ **内存空间占用：**
  + **`ArrayList`底层是数组，内存连续，节省内存，但尾部会预留⼀定的容量空间，浪费内存**
  + **`LinkedList` 是双向链表需要存储数据，每个节点需要两个指针，更占用内存**

+ **`ArrayList`和`LinkedList`都不是线程安全的**



### **`ArrayList` 扩容**

+ **`ArrayList`初始容量为0，当第一次添加数据的时候才会初始化容量为10**
+ **`ArrayList`在进行扩容的时候是原来容量的1.5倍，每次扩容都需要拷贝数组**
+ **返回添加成功布尔值**



### 数组和`List`之间的转换

+ **数组转`List`，使用JDK中`java.util.Arrays`工具类的`asList`方法(修改数组List会受影响)****
+ **List转数组，使用`List`的`toArray`方法。无参`toArray`方法返回`object`数组，传入初始化长度的数组对象，返回该对象数组(修改`List`数组不会受影响)**



### `Set`集合实现类

+ **`HashSet`：无序、不重复、无索引**
  + **底层使用哈希表存储数据，基于 `HashMap` 实现**
  + **JDK8之前：数组＋链表；JDK8开始：数组＋链表＋红黑树**
+ **`LinkedHashSet`：有序、不重复、无索引**
  + **使用双向链表记录存储顺序**
+ **`TreeSet`：可排序、不重复、无索引**
  + **基于红黑树实现排序**



### `HashSet` 添加元素时的去重

+ **计算该元素的哈希码，判断对象加⼊的位置。如果该位置还没有元素，直接将该元素添加到这个位置上。**
+ **如果该位置已经有其他元素了，`HashSet` 会遍历该位置上的链表（或红黑树），然后对链表中的每个元素逐个调用其 `equals()` 方法，与要添加的元素进行比较。如果找到一个元素与要添加的元素相等（根据 `equals()` 方法的判断），`HashSet` 则认为这是一个重复元素，不会添加它到集合中。如果链表中没有相等的元素，则将要添加的元素加入到链表末尾（或红黑树中）。**



### `equals()` ⽅法被覆盖过，则 `hashCode()` ⽅法也必须被覆盖 

**如果两个对象在 `equals()` 方法中被判断为相等，但它们的 `hashCode()` 方法返回不同的哈希码，那么当你尝试将这两个对象存储在哈希表等集合中时，它们可能被存储在不同的位置。**





### `Map` **实现类**

+ **`HashMap`：无序、不重复、无索引**
  + **利用键计算哈希值**
  + **如果键存储的是自定义对象，需要重写`hashCode()`和`equals()`方法**
  + **如果值存储自定义对象，不需要重写`hashCode()`和`equals()`方法**
+ **`LinkedHashMap`：有序、不重复、无索引**
  + **使用双向链表记录存储顺序**
+ **`TreeSet`：可排序、不重复、无索引**
  + **基于红黑树实现排序**
  + **对键进行排序，默认按照键的从小到大进行排序，也可以自己规定键的排序规则**



### `HashMap` `put(key, value)` 流程

1. **计算哈希码： 调用键对象的`hashCode()`方法来计算键的哈希码。哈希码是一个整数，用来确定键值对在哈希表中的存储位置。之后使用扰动函数进一步处理，减少哈希冲突的概率。**

   ```java
   return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
   ```

2. **计算索引位置： 通过 `(n - 1) & hash` 判断当前元素存放位置**

3. **查找键是否存在： 在选定的槽位中，遍历链表或红黑树来检查是否已经存在具有相同键的键值对。这是通过调用键对象的`equals()`方法来进行比较的。**

4. **插入或更新键值对： 如果在当前槽位的链表或树中找到了相同的键，`HashMap`会更新对应的值；如果没有找到相同的键，它会在链表或红黑树中插入一个新的键值对。**

5. **检查是否需要扩容： 在插入键值对后，HashMap会检查当前的键值对数量是否超过了负载因子阈值。如果超过了阈值，HashMap会触发扩容操作，即重新分配更大的内部数组，并重新计算所有键的哈希码，以确保分布均匀。**



### `HashMap` 1.7 & 1.8

+ **JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合，创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。**
+ **JDK1.8之后：当链表长度大于國值（默认为8） 时并且数组长度达到64时，将链表转化为红黑树，以减少搜索时间。扩容`resize(）`时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表**



### `HashMap` 扩容机制

+ **在键值对数量超过阈值或初始化的时候需要调用`resize()`方法进行扩容，第一次添加数据初始化数组长度为16，以后每次当存储的键值对数量达到当前哈希表容量与负载因子的乘积时，就会触发扩容**
+ **每次扩容时，`HashMap`会创建一个新的哈希表，其容量是当前容量的两倍**
+ **对于每个键值对，`HashMap`会计算新的索引位置，并将其插入新的槽位中**



### `HashMap`的数组长度一定是2的次幂

+ **计算索引时效率更高：如果是2的n次幂可以使用位与运算代替取模 `hash & (Capacity - 1)`**
+ **扩容时重新计算索引效率更高：**
  + **`e.hash & oldCap = 0` -> 元素停留在原始位置**



### 头插法死循环

**在JDK7的`hashmap`中在数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中，有可能导致死循环**

**线程一：读取到当前的`hashmap`数据，数据中存在一个链表，在准备扩容时，线程二介入**

**线程二：也读取`hashmap`，直接进行扩容。因为是头插法，链表的顺序会进行颠倒过来。比如原来的顺序是AB，扩容后的顺序是BA，线程二执行结束。**

**线程一：继续执行的时候就会出现死循环的问题。**

**线程一先将A移入新的链表，再将B插入到链头，由于另外一个线程的原因，B的next指向了A，所以B->A->B,形成循环。**

**JDK8 将扩容算法做了调整，使用尾插法，就避免了idk7中头插法死循环的问题**

### `HashMap` 的加载因子是0.75

+ **加载因子太低会导致大量的空桶浪费空间**
+ **加载因子太高会导致大量的碰撞，降低性能**
+ **0.75在大多数情况下提供了较好的性能和空间利用率**









