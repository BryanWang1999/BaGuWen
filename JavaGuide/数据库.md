# 数据库

### 字符串数据类型

+ **CHAR** → 参数为当前字符串能够存储的最大长度，**CHAR(10)** 如果未占用10个字节，也会用空格补位 性能高
+ **VARCHAR** → 可以变长 性能较差



### 执行顺序

```sql
from -> where -> group by -> having -> select -> order by -> limit
```



### 约束

+ 定义：约束是作用于表中字段上的规则，用于限制存储在表中的数据。

### <img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/Screen%20Shot%202023-07-25%20at%2010.57.26%20AM.png" alt="Screen Shot 2023-07-25 at 10.57.26 AM" style="zoom: 33%;" />

```sql
CREATE TABLE tb_user(
	id int AUTO_INCREMENT PRIMARY KEY COMMENT 'ID唯一标识',
	name varchar(10) NOT NULL UNIQUE COMMENT '姓名' ,
	age int check (age > 0 && age <= 120) COMMENT '年龄' ,
	status char(1) default '1' COMMENT '状态',
	gender char(1) COMMENT '性别'
);
```



### 外键约束

```sql
ALTER TABLE 表名 ADD constraint 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名) ;
```



### where 与 having 的区别

+ **执行时机不同**：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组 之后对结果进行过滤。
+ **判断条件不同**：where不能对聚合函数进行判断，而having可以。



### 多表关系

- **一对多**：在多的一方建立外键，指向一的一方的主键

- **多对多**：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键

- **一对一**：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)

  

### 外键约束删除/更新行为

添加了外键之后，再删除父表数据时产生的约束行为，我们就称为删除/更新行为。具体的删除/更新行 为有以下几种:



<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/Screen%20Shot%202023-07-25%20at%2011.03.05%20AM.png" alt="Screen Shot 2023-07-25 at 11.03.05 AM" style="zoom: 33%;" />

```sql
ALTER TABLE 表名 ADD constraint 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名) ON UPDATE CASCADE ON DELETE CASCADE;
```





### 联合查询

+ **union all** 会将全部的数据直接合并在一起
+ **union** 会对合并之后的数据去重



 ### 子查询

+ SQL语句中嵌套SELECT语句，称为**嵌套查询**，又称**子查询**。

1. 标量子查询（子查询结果为单个值）

   常用的操作符：= <> > >= < <=

   ```sql
   select * from emp where dept_id = (select id from dept where name = '销售部');
   ```

2. 列子查询(子查询结果为一列)

   常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL

   ```sql
   select * from emp where dept_id in (select id from dept where name = '销售部' or name = '市场部');
   -- 比财务部 所有人工资都高的员工信息
   select * from emp where salary > all ( select salary from emp where dept_id = (select id from dept where name = '财务部') );
   ```

   <img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/Screen%20Shot%202023-07-25%20at%2011.32.24%20AM.png" alt="Screen Shot 2023-07-25 at 11.32.24 AM" style="zoom: 33%;" />

3. 行子查询(子查询结果为一行)

   常用的操作符：= 、<> 、IN 、NOT IN

   ```sql
   -- 查询与 "张无忌" 的薪资及直属领导相同的员工信息 ;
   select * from emp where (salary,managerid) = (select salary, managerid from emp where name = '张无忌');
   ```

4. 表子查询(子查询结果为多行多列)

   常用的操作符：IN

   ```sql
   -- 查询与 "鹿杖客" , "宋远桥" 的职位和薪资相同的员工信息
   select * from emp where (job,salary) in ( select job, salary from emp where name = '鹿杖客' or name = '宋远桥' );
   ```

   

### 列举几种表连接方式

- 内连接：相当于查询A、B交集部分数据
  - 自然连接：自然连接是根据两个表之间的相同列进行连接的操作。它会自动查找两个表中具有相同列名和相同值的行，并将它们合并成一行。
  - 等值连接：给定条件进行查询
- 外连接
  - 左连接：查询左表所有数据，以及两张表交集部分数据
  - 右连接：查询右表所有数据，以及两张表交集部分数据
- 交叉连接：返回两表的笛卡尔积（对于所含数据分别为m、n的表，返回m*n的结果）
- 自连接：当前表与自身的连接查询，自连接必须使用表别名



### MySQL 执行流程

#### 连接器

- 与客户端进行 TCP 三次握手建立连接；
- 校验客户端的用户名和密码，如果用户名或密码不对，则会报错；
- 如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；

#### 查询缓存

**查询语句(只针对select语句)如果命中查询缓存则直接返回，否则继续往下执行。**MySQL 8.0 已删除该模块

#### 解析 SQL

**通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；**

+ **词法分析**：MySQL 会根据你输入的字符串识别出关键字出来，构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。

+ **语法分析**：根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。

#### 执行 SQL

- 预处理阶段：检查表或字段是否存在；将 `select *` 中的 `*` 符号扩展为表上的所有列。
- 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；(表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引)
- 执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；

























### 事务的概念和特性

概念：事务是一个操作序列，不可分割的工作单位

**特性（ACID）：**

- **原子性**（Atomicity）：事务是不可分割的操作单元，事务的所有操作要么全部提交成功，要么全部失败回滚
- **一致性**（Consistency）：事务完成时，必须使所有的数据都保持一致状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的
- **隔离性**（Isolation）：确保每个事务的执行都不会被其他并发事务所干扰
- **持久性**（Durability）：事务一旦提交或回滚，对数据的修改是永久性的



默认MySQL的事务是自动提交的，也就是说，当执行一条DML语句，MySQL会立即隐式的提交事务。

```sql
SELECT @@autocommit;
SET @@autocommit = 0; -- 查看/设置事务提交方式

start transaction;  -- 开启事务
BEGIN; -- 开启事务
ROLLBACK; -- 回滚事务
COMMIT; -- 提交事务
```



### 并发事务问题

- **丢失修改**：一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改

- **脏读**：个事务读取了另一个事务尚未提交的数据

- **不可重复读**：一个事务先后读取同一条记录，但两次读取的数据不同

- **幻读**：一个事务多次执行查询操作，由于其它事务执行了插入或删除操作，会导致每次返回不同的结果集

  

### 数据库的四种隔离级别

- **未提交读**（Read Uncommited）：在一个事务提交之前，它的执行结果对其它事务也是可见的。会导致脏读、不可重复读、幻读
- **提交读**（Read Commited）：一个事务只能读取已经提交的数据。可避免脏读问题
- **可重复读**（Repeatable Read）：可以确保同一个事务在多次读取同样的数据时得到相同的结果。**（MySQL的默认隔离级别）**。可避免不可重复读
- **串行化**（Serializable）：强制事务串行执行，使之不可能相互冲突，从而解决幻读问题。可能可能会牺牲一定的并发性能

```sql
SELECT @@TRANSACTION_ISOLATION;
SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE }
```



### MySQL 的架构

+ **Server 层负责建立连接、分析和执行 SQL。**
+ **存储引擎层负责数据的存储和提取**。**支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的**



### InnoDB 存储引擎

MySQL 5.5 之后，InnoDB是默认的 MySQL 存储引擎

+ **支持事务**
+ **支持行级锁，提高并发性能**
+ **支持外键约束**

文件：idb文件，存放表结构、数据和索引



<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/Screen%20Shot%202023-07-28%20at%2011.33.50%20AM.png" alt="Screen Shot 2023-07-28 at 11.33.50 AM" style="zoom: 33%;" />

+ **表空间** : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以 包含多个Segment段。
+ **段** : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。 
+ **区** : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为 16K， 即一个区中一共有64个连续的页。
+ **页** : 页是组成区的最小单元， 页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。
+ **行** : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段(后面会详细介绍)。



### 存储引擎

```sql
CREATE TABLE 表名(
		字段1 字段1类型 [ COMMENT 字段1注释 ] ,
		...
		字段n 字段n类型 [COMMENT 字段n注释 ]
) ENGINE = INNODB [ COMMENT 表注释 ] ;

show engines;
```



### MyISAM 存储引擎

如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完 整性、并发性要求不是很高，适合使用 MyISAM 存储引擎

MyISAM是MySQL早期的默认存储引擎

+ **不支持事务**
+ **支持表锁，不支持行锁**
+ **不支持外键约束**



### Memory 存储引擎

适合作为临时表或缓存使用

+ **内存存放**
+ **默认使用hash索引**

### 索引

**索引是帮助存储引擎快速获取数据的一种数据结构**

**优点：**

+ 提高数据检索的效率，降低数据库的IO成本
+ 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。

**缺点：**

+ 索引列占用空间
+ 索引大大提高了查询效率，同时却也降低更新表的速度， 如对表进行INSERT、UPDATE、DELETE时，效率降低。

### 索引**分类** - 数据结构

+ B+tree索引：最常见的索引类型
+ Hash索引：底层是用哈希表实现, 只有精确匹配索引列的查询才有效, 不支持范围查询(仅Memory引擎支持)
+ Full-text索引：用来模糊匹配查找文本中的关键字(全文索引)

### B-Tree

以一颗最大度数(树的度数指的是一个节点的子节点个数)（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5 个指针：

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/Screen%20Shot%202023-08-01%20at%2010.57.08%20AM.png" alt="Screen Shot 2023-08-01 at 10.57.08 AM" style="zoom:50%;" />



### B+树

以一颗最大度数（max-degree）为4（4阶）的b+tree为例：

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/Screen%20Shot%202023-08-01%20at%2010.58.48%20AM.png" alt="Screen Shot 2023-08-01 at 10.58.48 AM" style="zoom: 50%;" />

+ **所有的数据都会出现在叶子节点**
+ **叶子节点形成一个单向链表**
+ **非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的**



### MySQL B+树

MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，**增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能，利于排序。**

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/Screen%20Shot%202023-08-01%20at%2011.02.10%20AM.png" alt="Screen Shot 2023-08-01 at 11.02.10 AM" style="zoom:50%;" />





### Hash索引

哈希索引就是**采用一定的hash算法，将键值换算成新的hash值**，映射到对应的槽位上，然后存储在 hash表中。如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/Screen%20Shot%202023-08-01%20at%2011.04.25%20AM.png" alt="Screen Shot 2023-08-01 at 11.04.25 AM" style="zoom:50%;" />

+ **Hash索引只能用于对等比较(=，in)，不支持范围查询（between，>，< ，...）**
+ **无法利用索引完成排序操作**
+ **查询效率高，通常(不存在hash冲突的情况)只需要一次检索就可以了，效率通常要高于B+tree索 引**

### 为什么InnoDB存储引擎选择使用B+tree索引结构

+ 相对于B-tree
  + **IO次数少**：B+树的中间结点只存放索引，数据都存在叶结点中，因此中间结点可以存更多的索引，导致B+树的高度相对较小，减少了磁盘I/O操作次数
  + **范围查询效率更高**：B+树的所有叶节点通过链表连接在一起，可以很方便地进行范围查询，而B树则需要通过中序遍历才能实现范围查询。
  + **更适合顺序访问**：B+树的叶节点形成有序链表，对B+树进行顺序访问时，数据的访问效率更高。
  + **查询效率更加稳定**：每次查询都需要从根结点到叶结点，路径长度相同，所以每次查询的效率都差不多
+ 相对Hash索引，B+tree支持范围查询及排序操作；

### 索引分类

+ **主键索引：**主键索引就是建立在主键字段上的索引，默认自动创建, 只能有一个
+ **唯一索引：**唯一索引建立在 UNIQUE 字段上的索引，可以有多个
+ **普通索引：**普通索引就是建立在普通字段上的索引，可以有多个
+ **全文索引：**全文索引用来模糊匹配查找文本中的关键字，可以有多个

### 索引分类 - 存储

+ **聚集索引：**将数据与索引存储在一起，索引结构的叶子节点保存了行数据，必须有,而且只 有一个
+ **二级索引：**将数据与索引分开存储，索引结构的叶子节点存放的是主键值，可以存在多个

聚集索引选取规则:

+ 如果存在主键，主键索引就是聚集索引。
+ 如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。 
+ 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/Screen%20Shot%202023-08-01%20at%203.52.35%20PM.png" alt="Screen Shot 2023-08-01 at 3.52.35 PM" style="zoom: 50%;" />

### 回表查询

**先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。**



### 索引语法 

```sql
CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name,... ); // 创建索引
SHOW INDEX FROM table_name;  // 查看索引
DROP INDEX index_name ON table_name ; // 删除索引
```



### 定位慢查询 - 慢查询日志

慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有 SQL语句的日志。

```sql
# 开启MySQL慢日志查询开关
slow_query_log=1
# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time=2
```



### EXPLAIN / DESC

**可以采用EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息**

```sql
-- 直接在select语句之前加上关键字 explain / desc
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件 ;
```

![Screen Shot 2023-08-02 at 4.12.30 PM](%E6%95%B0%E6%8D%AE%E5%BA%93.assets/Screen%20Shot%202023-08-02%20at%204.12.30%20PM.png)



+ **select_type**：表示 SELECT 的类型，常见的取值有
  + **SIMPLE**（简单表，即不使用表连接或者子查询）
  + **PRIMARY**（主查询，即外层的查询）
  + **UNION**（UNION 中的第二个或者后面的查询语句）
  + **SUBQUERY**（SELECT/WHERE之后包含了子查询）
+ **type**：表示连接类型，性能由好到差的连接类型为NULL、system、const、 eq_ref、ref、range、 index、all 。
  + **system**：查询系统中的表
  + **const**：根据主键查询
  + **eq_ref**：主键索引查询或唯一索引查询
  + **ref**：索引查询
  + **range**：范围查询
  + **index**：索引树扫描
  + **all**：全盘扫描
+ **possible_key**：显示可能应用在这张表上的索引，一个或多个。
+ **key**：实际使用的索引，如果为NULL，则没有使用索引。
+ **key_len**：表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。
+ **filtered**：表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。
+ **Extra**：额外的优化建议
  + **Using where; Using Index** -> 查找使用了索引，需要的数据都在索引列中能找到，不需要回表查询数据
  + **Using index condition** -> 查找使用了索引，但是需要回表查询数据



### 索引失效情况

+ **违反最左前缀法则**

  + 如果使用了联合索引，要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始， 并且不跳过索引中的列。如果跳跃某一列，后面的索引将会失效。(与SQL语句编写顺序无关)

+ **联合索引中，出现范围查询(>, <, >=, <=)，范围查询右侧的列索引失效。**

  + B+树叶子节点通过链表连接。只有当前一个索引列是确定值的时候，下一个索引列的值才是递增的状态

+ **在索引列上进行运算操作，索引将失效。**

  ```sql
  # 当根据phone字段进行等值匹配查询时, 索引生效。
  select * from tb_user where phone = '17799990015';
  # 当根据phone字段进行函数运算操作之后，索引失效。
  select * from tb_user where substring(phone,10,2) = '15';
  ```

+ **字符串不加引号：字符串类型字段使用时，不加引号，索引将失效。**

+ **模糊查询：如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。**

  ```sql
  explain select * from tb_user where profession like '软件%';
  explain select * from tb_user where profession like '%工程'; # 索引失效
  explain select * from tb_user where profession like '%工%'; # 索引失效
  ```

+ **OR语句前后没有同时使用索引**

+ **如果MySQL估计全表扫描比索引快，则不使用索引**



### 覆盖索引

**尽量使用覆盖索引（不需要回表，一次扫描就完成了查询），减少select *** 

+ **Using where; Using Index** -> 查找使用了索引，需要的数据都在索引列中能找到，不需要回表查询数据
+ **Using index condition** -> 查找使用了索引，但是需要回表查询数据

```SQL
select id,username,password from tb_user where username = 'itcast'; # 优化：根据 username, password 建立联合索引，不需要回表
```



### 前缀索引

前缀索引是指对字符类型字段的前几个字符建立的索引

```sql
create index idx_xxxx on table_name(column(n)) ; # n -> 前缀长度
```



### 单列索引 & 联合索引

+ **单列索引**：即一个索引只包含单个列。
+ **联合索引**：即一个索引包含了多个列。

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/Screen%20Shot%202023-08-02%20at%205.07.38%20PM.png" alt="Screen Shot 2023-08-02 at 5.07.38 PM" style="zoom:50%;" />

- **先按phone进行排序**
- **phone一致再按name进行排序**
- **如果查询 id, phone, name 不需要回表**



### 索引设计原则

+ 针对于数据量较大，且查询比较频繁的表建立索引
+ 针对于经常出现在 order by/group by/where后面的字段建立索引
+ 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高
+ 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引
+ 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间， 避免回表，提高查询效率
+ 要控制索引的数量，索引越多，维护索引结构的代价也就越大，会影响增 删改的效率
+ 如果索引列不能存储NULL值，需要在创建表时使用NOT NULL进行约束。当优化器知道每列是否包含 NULL值时，它可以更好地确定哪个索引最有效地用于查询



### SQL 优化 - 插入数据

+ **批量插入数据**

  ```sql
  Insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry'); 
  ```

+ **手动控制事务**

  ```sql
  start transaction;
  insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');
  insert into tb_test values(4,'Tom'),(5,'Cat'),(6,'Jerry');
  insert into tb_test values(7,'Tom'),(8,'Cat'),(9,'Jerry');
  commit;
  ```

+ **主键顺序插入，性能要高于乱序插入**

+ **大批量插入数据时，使用`load`指令进行插入**



### SQL 优化 - 主键

+ **尽量降低主键的长度**
  + 二级索引挂的是主键，如果主键过大，存储时会占用大量磁盘空间，搜索时会耗费大量磁盘IO
+ **插入数据时，尽量选择顺序插入，可以选择使用AUTO_INCREMENT自增主键**
  + 乱序插入容易引起页分裂现象
+ **避免对主键的修改**
  + 可能需要修改索引结构，代价太大



### SQL 优化 - `order by`

+ **根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则**
+ **尽量使用覆盖索引**
+ **多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）**



### SQL 优化 - `group by`

+ **在分组操作时，可以通过索引来提高效率**
+ **分组操作时，索引的使用也是满足最左前缀法则的**



### SQL 优化 - `limit`

在进行limit分页查询时，越往后，分页查询效率越低

```sql
select * from tb_sku order by id limit 2000000,10
```

+ **优化思路：覆盖索引 + 子查询**

```sql
select * from tb_sku t (select id from tb_sku order by id limit 2000000,10) a where t.id = a.id;
```



### SQL 优化 - `count`

+ **count(主键)**：InnoDB 引擎会遍历整张表，把每一行的主键id 值都取出来，返回给服务层。 服务层拿到主键后，直接按行进行累加(主键不可能为null)
+ **count(字段)**：
  + 没有not null 约束 : InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加。 
  + 有not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。

+ **count(数字)**：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1” 进去，直接按行进行累加。
+ **count(*)**：InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。

**效率：count(字段) < count(主键 id) < count(1) ≈ count(*)**



### SQL 优化 -  `update`

**尽量根据主键/索引字段进行数据更新**





### 全局锁

全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句都将被阻塞。

其典型的使用场景是做**全库的逻辑备份**，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。

```sql
flush tables with read lock ; # 加全局锁
unlock tables ; # 释放锁
```

+ 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。
+ 如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟。
+ 不加锁的备份 → 通过**快照读**实现



### 表级锁

**表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。**

+ **表锁** 
+ **元数据锁（meta data lock，MDL）** 
+ **意向锁**



### 表级锁 - 表锁 

+ **表共享读锁（read lock）** 
+ **表独占写锁（write lock）**

```sql
lock tables 表名... read/write; # 加锁
unlock tables; # 释放锁
```

**读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。**



### 表级锁 - 元数据锁

+ **元数据：存储表结构信息**
+ **MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。 为了避免 DML与 DDL冲突，保证读写的正确性。**
+ **当对一张表进行增删改查的时候，加MDL读锁(共享)**
+ **当对表结构进行变 更操作的时候，加MDL写锁(排他)**



**DDL（Data Definition Language）数据定义语言：**

+ **CREATE**：创建数据库对象，如创建表、视图等。
+ **ALTER**：修改数据库对象的结构，如添加、修改或删除列、约束等。
+ **DROP**：删除数据库对象，如删除表、视图等。

**DML（Data Manipulation Language）数据操作语言：**

- **SELECT**：用于查询数据。
- **INSERT**：用于插入新数据到数据库表中。
- **UPDATE**：用于更新数据库表中的数据。
- **DELETE**：用于删除数据库表中的数据。



### 表级锁 - 意向锁

**为了避免DML在执行时，加的行锁与表锁的冲突，在InnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。**

+ **意向共享锁(IS)**: 由语句`select ... lock in share mode`添加 。 与表锁共享锁(read)兼容，与表锁排他锁(write)互斥。
+ **意向排他锁(IX)**: 由`insert、update、delete、select...for update`添加 。与表锁共 享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥，多个事务可以同时持有意向锁(IX)。



### 行级锁

**每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在 InnoDB存储引擎中。**

+ **行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行update和delete。在 RC、RR隔离级别下都支持。**
+ **间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事 务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持。**
+ **临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。 在RR隔离级别下支持。**



### 行锁

+ **共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。**
+ **排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。**

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/Screen%20Shot%202023-08-08%20at%206.30.38%20PM.png" alt="Screen Shot 2023-08-08 at 6.30.38 PM" style="zoom:50%;" />



+ **针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。** 
+ **InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会升级为表锁。**



### 间隙锁&临键锁

**默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。**

+ **索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。**
+ **索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁。**
+ **索引上的范围查询(唯一索引)--会访问到不满足条件的第一个值为止。**

**间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会 阻止另一个事务在同一间隙上采用间隙锁。**



### 事务原理

+ **原子性、一致性、持久性 -> redo log日志 & undo log日志**
+ **隔离性 -> 锁 & MVCC**



### redo log

**重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。**

**该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用 于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。**



### undo log

**回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和 MVCC(多版本并发控制) 。**

**undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的 update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。**



### MVCC

+ **当前读：**
  + **读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加 锁。对于我们日常的操作，如：`select ... lock in share mode`(共享锁)，`select ... for update`、`update`、`insert`、`delete`(排他锁)都是一种当前读**
+ **快照读：**
  + **简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据， 不加锁，是非阻塞读**
    + **Read Committed：每次select，都生成一个快照读。**
    + **Repeatable Read：开启事务后第一个select语句才是快照读的地方。**
    +  Serializable：快照读会退化为当前读。**
+ **MVCC：**
  + **全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本， 使得读写操作没有冲突。MVCC的具体实现，还需 要依赖于数据库记录中的三个隐式字段、undo log日志、readView。**



### MVCC - 隐藏字段<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/Screen%20Shot%202023-08-11%20at%2012.47.05%20PM.png" alt="Screen Shot 2023-08-11 at 12.47.05 PM" style="zoom:50%;" />



### MVCC - undo log日志

**不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录**

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/Screen%20Shot%202023-08-11%20at%2012.58.38%20PM.png" alt="Screen Shot 2023-08-11 at 12.58.38 PM" style="zoom:50%;" />



### MVCC - readView

**ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id**

**ReadView中包含了四个核心字段：**

<img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/Screen%20Shot%202023-08-11%20at%201.00.48%20PM.png" alt="Screen Shot 2023-08-11 at 1.00.48 PM" style="zoom: 33%;" />

**版本链数据的访问规则(trx_id 代表当前undolog版本链对应事务ID)：**

### <img src="%E6%95%B0%E6%8D%AE%E5%BA%93.assets/Screen%20Shot%202023-08-11%20at%201.04.06%20PM.png" alt="Screen Shot 2023-08-11 at 1.04.06 PM" style="zoom:33%;" />

+ **READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。**
+ **REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。**



### 两段锁协议

事务必须严格分为两个阶段对数据进行**加锁和解锁**的操作，第一阶段加锁，第二阶段解锁。也就是说一个事务中一旦释放了锁，就不能再申请新锁了。

**可串行化调度**是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。事务遵循两段锁协议是保证可串行化调度的充分条件。



### 数据库的范式

- **第一范式**：**属性不可再分**。

- **第二范式：每个非主属性完全依赖于候选键集(一个表中可以用来唯一标识每一行数据的所有字段的集合)**

  - B完全依赖于A，就是说A中的所有属性唯一决定B，属性少了就不能唯一决定，属性多了则有冗余（叫依赖不叫完全依赖）。举例：（学号，课程名）这个主属性集可以唯一决定成绩，但是对于学生姓名这个属性，（学号，课程名）这个属性集就是冗余的，所以学生姓名不完全依赖于（学号，课程名）这一属性集
  - 候选键集：某一组属性能够唯一确定其它的属性（主键就是从候选键集中选的一个键），而其子集不能，这样的属性组中的属性就是主属性

- **第三范式：非主属性不传递依赖于主属性**

  - 传递依赖：如果C依赖于B，B依赖于A，那么C传递依赖于A

    | 图书编号 | 图书名称 | 作者 | 作者国家 |
    | -------- | -------- | ---- | -------- |
    |          |          |      |          |

- **BCNF：确保每个非主属性都完全依赖于候选键集（包括主键），而不是只依赖于部分候选键。**

  | 订单号 | 产品号 | 产品名称 | 客户号 | 客户名称 |
  | ------ | ------ | -------- | ------ | -------- |
  |        |        |          |        |          |



### Drop/Delete/Truncate的区别

- **Delete用来删除表的全部或者部分数据，表的定义和结构不受影响，可以回滚。删除很慢，逐行删除。**
- **Truncate删除表中的全部数据，表的定义和结构不受影响，不能回滚。操作比DELETE操作快很多，不是逐行删除，而是直接删除整个数据块。**
- **Drop用来从数据库中删除表，所有的数据行，索引和约束被删除；不能回滚。**



### 关系型数据库和非关系型数据库的区别

- 前者高度组织化结构化数据；后者存储的数据结构不固定更加灵活，可以减少一些空间和时间的开销
- 前者支持结构化查询语言，支持复杂的查询功能和表关联。后者只能进行简单的查询
- 前者支持事务，具有ACID特性



