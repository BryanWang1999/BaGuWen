### 缓存穿透

**缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会到达数据库**

+ **缓存空对象**
  + **优点：实现简单**
  + **缺点：额外的内存消耗、可能造成短期的不一致**
+ **布隆过滤**
  + **优点：内存占用较少**
  + **缺点：实现复杂、存在误判可能(判断不存在则一定不存在)**



### **缓存雪崩**

**缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库**

+ **给不同Key的TTL添加随机值**
+ **利用Redis集群提高服务的可用性**
+ **限流，避免同时处理大量请求**



### 缓存击穿

**缓存击穿问题也叫热点 Key 问题，指一个被高并发访问并且缓存重建业务较复杂的 key 突然失效了，导致大量请求到达数据库**

+ **互斥锁**
  + **强一致性、没有额外的内存消耗**
  + **性能差**
+ **逻辑过期**
  + **高可用、性能好**
  + **有额外的内存消耗**



### 数据结构

+ **String**
+ **List**
  + **类似双向链表**
+ **Hash**
  + **适合存储对象数据**
+ **Set**
  + **无序集合**
  + **存放数据不能重复；可以获取交集、并集**
+ **ZSet**
  + **每一个元素都需要指定一个 score 值和 member 值**
  + **根据 score 值排序、 member 必须唯一、可以根据 member 查询分数**



### **SkipList**

**SkipList 是一种特殊的双向链表，用于存储有序元素，它在插入、删除和搜索操作上都能够在平均情况下实现 O(log n) 的时间复杂度。**

**SkipList 通过添加多层索引来加速搜索操作。每一层都是一个有序的链表，不同层指针到下一个节点的跨度不同。**





#### 过期数据删除机制

+ **惰性删除：不是在TTL到期后就立刻删除，而是在访问一个key的时候，检查该key的存活时间，如果已经过期才执行删除 (CPU友好)**
+ **周期删除：每隔⼀段时间抽取⼀批 key 执⾏删除过期 key 操作 (内存友好)**



#### **内存淘汰机制**

+ **不淘汰任何key**
+ **对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰**
+ **对全体key ，随机进行淘汰**
+ **对设置了TTL的key ，随机进行淘汰**
+ **对全体key，基于LRU算法进行淘汰**
+ **对设置了TTL的key ，基于LRU算法进行淘汰**
+ **对全体key，基于LFU算法进行淘汰**
+ **对设置了TTL的key ，基于LFU算法进行淘汰**



#### 持久化机制

+ RDB：
