#### 使用 Redis 实现短信登录功能，解决了集群模式下的 Session 共享问题，并使用拦截器实现用户的登录校验功能和权限刷新功能

**每台 Tomcat 都会有自己的 Session 空间。多台 Tomcat 并不共享 session 存储空间，当请求切换到不同 tomcat 服务时导致数据丢失的问题**

#### <img src="%E9%A1%B9%E7%9B%AE.assets/Screen%20Shot%202023-09-03%20at%203.51.01%20PM.png" alt="Screen Shot 2023-09-03 at 3.51.01 PM" style="zoom: 33%;" />

**保存验证码：使用 String 数据结构**

- **key → 确保每一个不同的手机号保存的 key 都是不一样的**
- **value**

**保存用户到 Redis：使用 Hash 数据结构**

- **key → 使用随机 token → 一个随机字符串 (保证唯一 & 客户端请求时携带)**
  - **session 是 Tomcat 维护的**
  - **token 需要手动维护，返回给前端**

```java
@Override
public Result sendCode(String phone, HttpSession session) {
    // 1. 校验手机号
    if (RegexUtils.isPhoneInvalid(phone)) {
        // 2. 如果不符合，返回错误信息
        return Result.fail("手机号格式错误");
    }

    // 3. 符合，生成验证码
    String code = RandomUtil.randomNumbers(6);

    // 4. 保存验证码到session
    // session.setAttribute("code", code);

    // 4. 保存验证码到redis并设置有效期
    stringRedisTemplate.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);

    // 5. 发送验证码
    log.debug("发送短信验证码成功，验证码为{}", code);

    // 返回ok
    return Result.ok();
}
```

```java
@Override
public Result login(LoginFormDTO loginForm, HttpSession session) {
    // 1. 检验手机号
    String phone = loginForm.getPhone();
    if (RegexUtils.isPhoneInvalid(phone)) {
        // 如果不符合，返回错误信息
        return Result.fail("手机号格式错误");
    }

    // 2. 从redis获取验证码并校验
    String cacheCode = stringRedisTemplate.opsForValue().get(LOGIN_CODE_KEY + phone);
    String code = loginForm.getCode();
    if (cacheCode == null || !cacheCode.equals(code)) { // 反向编码方式 -> 减少 if 嵌套
        // 3. 不一致，报错
        return Result.fail("验证码错误");
    }

    // 4. 一致，根据手机号查询用户 select * from tb_user where phone = ?;
    User user = query().eq("phone", phone).one();

    // 5. 判断用户是否存在
    if (user == null) {
        // 6. 不存在，创建新用户并保存
        user = createUserWithPhone(phone);
    }


    // 7. 保存用户信息到redis中
    // 7.1 随机生成token，作为登录令牌
    String token = UUID.randomUUID().toString(true);
    // 7.2 将user对象转为Hash存储
    UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);
    // 7.3 存储
    String tokenKey = LOGIN_USER_KEY + token;
    Map<String, Object> userMap =  BeanUtil.beanToMap(userDTO, new HashMap<>(),
            CopyOptions.create()
                    .setIgnoreNullValue(true) // 忽略空值
                    .setFieldValueEditor((filename, fileValue) -> fileValue.toString())); // 对字段值的修改器，把fileValue转换为String
    stringRedisTemplate.opsForHash().putAll(tokenKey, userMap);
    // 7.4 设置token有效期
    stringRedisTemplate.expire(tokenKey, LOGIN_USER_TTL, TimeUnit.MINUTES);

    // 返回token给客户端
    return Result.ok(token);
}
```

**只要不停地访问，有效期就一直是30分钟 → 在拦截器中做，更新 Redis 有效期**

**有了拦截器以后，用户的请求不再能直接访问到 Controller，所有的请求必须先经过拦截器，再由拦截器判断该不该放行，请求是否能够访问到 Controller**



<img src="%E9%A1%B9%E7%9B%AE.assets/Screen%20Shot%202023-09-03%20at%203.58.57%20PM.png" alt="Screen Shot 2023-09-03 at 3.58.57 PM" style="zoom:33%;" />

<img src="%E9%A1%B9%E7%9B%AE.assets/Screen%20Shot%202023-09-03%20at%204.00.51%20PM.png" alt="Screen Shot 2023-09-03 at 4.00.51 PM" style="zoom:33%;" />



```java
public class RefreshTokenInterceptor implements HandlerInterceptor {

    private StringRedisTemplate stringRedisTemplate;

    public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 执行 Controller 之前需要做用户校验

        // 1. 获取请求头中的token
        String token = request.getHeader("authorization");
        if (StrUtil.isBlank(token)) {
            return true;
        }

        // 2. 基于token获取redis中的用户
        String key = LOGIN_USER_KEY + token;
        Map<Object, Object> userMap = stringRedisTemplate.opsForHash().entries(LOGIN_USER_KEY + token);

        // 3. 判断用户是否存在
        if (userMap.isEmpty()) {
            return true;
        }
        // 5. 将查询到的Hash数据转为UserDto对象
        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);

        // 6. 存在，保存用户信息到ThreadLocal
        UserHolder.saveUser(userDTO);

        // 7. 刷新token有效期
        stringRedisTemplate.expire(key, LOGIN_USER_TTL, TimeUnit.MINUTES);

        // 8. 放行
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 用户业务执行完毕，销毁对应用户信息，避免内存泄漏
        UserHolder.removeUser();
        HandlerInterceptor.super.afterCompletion(request, response, handler, ex);
    }
}
```

```java
public class LoginInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 1. 判断是否需要拦截(ThreadLocal中是否有用户)
        if(UserHolder.getUser() == null) {
            // 没有，需要拦截，设置状态码
            response.setStatus(401);
            // 拦截
            return false;
        }
        // 有用户，放行
        return true;
    }
}
```

```java
@Configuration
public class MvcConfig implements WebMvcConfigurer{

    @Resource
    private StringRedisTemplate stringRedisTemplate;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 登录拦截器
        registry.addInterceptor(new LoginInterceptor())
                .excludePathPatterns(
                        "/user/code",
                        "/user/login",
                        "/blog/hot",
                        "/shop/**",
                        "/shop-type/**",
                        "/upload/**",
                        "/voucher/**"
                )
                .order(1);

        // token刷新拦截器
        registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate))
                .addPathPatterns("/**")
                .order(0);
    }
}
```

```java
package com.hmdp.utils;

import com.hmdp.dto.UserDTO;

public class UserHolder {
    private static final ThreadLocal<UserDTO> tl = new ThreadLocal<>();

    public static void saveUser(UserDTO user){
        tl.set(user);
    }

    public static UserDTO getUser(){
        return tl.get();
    }

    public static void removeUser(){
        tl.remove();
    }
}
```



#### 使用 Redis 对高频访问信息进行缓存，降低了数据库查询的压力，解决了缓存穿透、缓存击穿问题

##### 缓存穿透

<img src="%E9%A1%B9%E7%9B%AE.assets/Screen%20Shot%202023-09-03%20at%204.08.00%20PM.png" alt="Screen Shot 2023-09-03 at 4.08.00 PM" style="zoom:33%;" />



```java
@Override
public Result queryById(Long id) {
    String key = CACHE_SHOP_KEY + id; // "cache:shop:"
    // 1. 从redis查询商铺缓存
    String shopJson = stringRedisTemplate.opsForValue().get(key); // 之后还需要把字符串反序列化为Java对象

    // 2. 判断是否存在
    if (StrUtil.isNotBlank(shopJson)) {
        // 3. 存在，直接返回
        Shop shop = JSONUtil.toBean(shopJson, Shop.class);
        return Result.ok(shop);
    }

    // 判断命中的是否是空值，此时是一个空字符串
    if (shopJson != null) {  // 不为null -> 是一个空字符串
        // 返回一个错误信息
        return Result.fail("店铺不存在");
    }

    // 4. 不存在，根据id查数据库
    Shop shop = getById(id);

    // 5. 不存在，返回错误
    if (shop == null) {
        // 将空值写入redis
        stringRedisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES); // 有效期为2分钟，较短
        // 返回错误信息
        return Result.fail("店铺不存在");
    }

    // 6. 存在，写入redis
    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);

    // 7. 返回
    return Result.ok(shop);
}
```



##### 缓存击穿 - 互斥锁

##### <img src="%E9%A1%B9%E7%9B%AE.assets/Screen%20Shot%202023-09-03%20at%204.11.11%20PM.png" alt="Screen Shot 2023-09-03 at 4.11.11 PM" style="zoom:33%;" />

- **锁 → 多个线程并行执行只能有一个成功 `setnx` 命令(String 下面的方法)**
  - **获取锁：`SETNX key value` → key 不存在的时候才能 set(设置一个有效期 → 防止服务出现异常，锁无法被释放)**
  - **释放锁：删除锁**

```java
// 获取锁
private boolean tryLock(String key) {
    Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", 10, TimeUnit.SECONDS); // 执行 SETNX
    return BooleanUtil.isTrue(flag); // 直接返回flag会做拆箱，有可能出现空指针，所以使用工具类处理
}

// 释放锁
private void unlock(String key) {
    stringRedisTemplate.delete(key);
}
```

```java
// 基于互斥锁方式解决缓存击穿
public Shop queryWithMutex(Long id) {
    String key = CACHE_SHOP_KEY + id; // "cache:shop:"
    // 1. 从redis查询商铺缓存
    String shopJson = stringRedisTemplate.opsForValue().get(key);

    // 2. 判断是否存在
    if (StrUtil.isNotBlank(shopJson)) {
        // 3. 存在，直接返回
        return JSONUtil.toBean(shopJson, Shop.class);
    }

    // 判断命中的是否是空值
    if (shopJson != null) {
        // 返回一个错误信息
        return null;
    }

    // 4. 实现缓存重建
    // 4.1 获取互斥锁
    String lockKey = LOCK_SHOP_KEY + id; // "lock:shop:"
    Shop shop = null;
    try {
        boolean isLock = tryLock(lockKey);
        // 4.2 判断是否获取成功
        if (!isLock) {
            // 4.3 失败，则休眠并重试
            Thread.sleep(50);
            return queryWithMutex(id);
        }

        // 4.4 成功，根据id查询数据库
        shop = getById(id);
        // 模拟重建延迟
        Thread.sleep(200);

        // 5. 不存在，返回错误
        if (shop == null) {
            // 将空值写入redis
            stringRedisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
            // 返回错误信息
            return null;
        }

        // 6. 存在，写入redis
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);
    } catch (InterruptedException e) {
        throw new RuntimeException(e);
    } finally {
        // 7. 释放互斥锁
        unlock(lockKey);
    }

    // 8. 返回
    return shop;
}
```



##### 缓存击穿 - 逻辑过期

<img src="%E9%A1%B9%E7%9B%AE.assets/Screen%20Shot%202023-09-03%20at%204.18.57%20PM.png" alt="Screen Shot 2023-09-03 at 4.18.57 PM" style="zoom:33%;" />



```java
private static final ExecutorService CACHE_REQUIRED_EXECUTOR = Executors.newFixedThreadPool(10);

// 逻辑过期
// 不需要考虑缓存穿透问题，不需要存null值，也不需要判断null值
public Shop queryWithLogicalExpire(Long id) {
    String shopKey = CACHE_SHOP_KEY + id; // "cache:shop:"
    // 1. 从redis查询商铺缓存
    String shopJson = stringRedisTemplate.opsForValue().get(shopKey);

    // 2. 判断是否存在
    if (StrUtil.isBlank(shopJson)) {
        // 3. 未命中，直接返回
        return null;
    }

    // 4. 命中，需要把json反序列化为对象
    RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class);
    JSONObject data = (JSONObject) redisData.getData();
    Shop shop = JSONUtil.toBean(data, Shop.class);

    LocalDateTime expireTime = redisData.getExpireTime();
    // 5. 判断是否过期
    if (expireTime.isAfter(LocalDateTime.now())) {
        // 5.1 未过期，直接返回店铺信息
        return shop;
    }

    // 5.2 已过期，需要缓存重建
    // 6. 缓存重建
    // 6.1 获取互斥锁
    String lockKey = LOCK_SHOP_KEY + id; // "lock:shop:"
    Boolean isLock = tryLock(lockKey);
    // 6.2 判断是否获取锁成功
    if (isLock) {
        // 6.3 成功，开启独立线程，实现缓存重建
        CACHE_REQUIRED_EXECUTOR.submit(() -> {
            // 重建缓存
            try {
                this.saveShop2Redis(id, 20L);
            } catch (Exception e) {
                throw new RuntimeException(e);
            } finally {
                // 释放锁
                unlock(lockKey);
            }
        });
    }

    // 6.4 返回过期的商铺信息
    return shop;
}
```

```java
public void saveShop2Redis(Long id, Long expireSecond) throws InterruptedException {
    // 1. 查询店铺数据
    Shop shop = getById(id);

    Thread.sleep(200);

    // 2. 封装逻辑过期时间
    RedisData redisData = new RedisData();
    redisData.setData(shop);
    redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSecond));

    // 3. 写入Redis
    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData));
}
```



#### 实现优惠券秒杀业务，使用 Redis + Lua 实现分布式锁，解决秒杀产生的一人一单问题，同时用乐观锁解决超卖问题

#### 超卖问题

#### <img src="%E9%A1%B9%E7%9B%AE.assets/Screen%20Shot%202023-09-04%20at%203.05.52%20PM.png" alt="Screen Shot 2023-09-04 at 3.05.52 PM" style="zoom:33%;" />

- **相当于用库存代替版本号**
- **优点：性能好**
- **缺点：存在成功率低的问题**

```java
@Override
@Transactional
public Result seckillVoucher(Long voucherId) {
    // 1. 查询优惠券
    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);

    // 2. 判断秒杀是否开始
    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {
        // 尚未开始
        return Result.fail("秒杀尚未开始！");
    }

    // 3. 判断秒杀是否结束
    if (voucher.getEndTime().isBefore(LocalDateTime.now())) {
        // 已经结束
        return Result.fail("秒杀尚未开始！");
    }

    // 4. 判断库存是否充足
    if (voucher.getStock() < 1) {
        // 库存不足
        return Result.fail("库存不足！");
    }

    // 5. 扣减库存
    boolean success = seckillVoucherService.update()
            .setSql("stock = stock - 1") // set stock = stock - 1
            // .eq("voucher_id", voucherId).eq("stock", voucher.getStock()) // where id = ? and stock = ? -> 失败率太高
            .eq("voucher_id", voucherId).gt("stock",0) // where id = ? and stock > 0
            .update();
    if (!success) {
        return Result.fail("库存不足！");
    }

    // 6. 创建订单
    VoucherOrder voucherOrder = new VoucherOrder();
    // 6.1 订单id
    long orderId = redisIDWorker.nextId("order");
    voucherOrder.setId(orderId);
    // 6.2 用户id
    long userId = UserHolder.getUser().getId();
    voucherOrder.setUserId(userId);
    // 6.3 代金券id
    voucherOrder.setVoucherId(voucherId);
    save(voucherOrder);

    // 7. 返回订单id
    return Result.ok(orderId);
}
```



#### 一人一单

```java
@Override
public Result seckillVoucher(Long voucherId) {
    // 1. 查询优惠券
    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);

    // 2. 判断秒杀是否开始
    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {
        // 尚未开始
        return Result.fail("秒杀尚未开始！");
    }

    // 3. 判断秒杀是否结束
    if (voucher.getEndTime().isBefore(LocalDateTime.now())) {
        // 已经结束
        return Result.fail("秒杀尚未开始！");
    }

    // 4. 判断库存是否充足
    if (voucher.getStock() < 1) {
        // 库存不足
        return Result.fail("库存不足！");
    }

    Long userId = UserHolder.getUser().getId();

    synchronized(userId.toString().intern()) { // 给不同用户加不同锁
        // 获取代理对象(事务)
        IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
        return proxy.createVoucherOrder(voucherId);
    }
}

@Transactional
public Result createVoucherOrder(Long voucherId) { // 这段逻辑加了悲观锁
    // 5. 一人一单
    Long userId = UserHolder.getUser().getId();

    // 5.1 查询订单
    int count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();

    // 5.2 判断是否存在
    if (count > 0) {
        // 用户已经购买过了
        log.error("用户已经购买过了！");
        return Result.fail("用户已经购买过了！");
    }

    // 6. 扣减库存
    boolean success = seckillVoucherService.update()
            .setSql("stock = stock - 1") // set stock = stock - 1
            // .eq("voucher_id", voucherId).eq("stock", voucher.getStock()) // where id = ? and stock = ?、
            .eq("voucher_id", voucherId).gt("stock",0) // where id = ? and stock > 0
            .update();
    if (!success) {
        log.error("库存不足！");
        return Result.fail("库存不足！");
    }

    // 7. 创建订单
    VoucherOrder voucherOrder = new VoucherOrder();
    // 7.1 订单id
    long orderId = redisIDWorker.nextId("order");
    voucherOrder.setId(orderId);
    // 7.2 用户id
    voucherOrder.setUserId(userId);
    // 7.3 代金券id
    voucherOrder.setVoucherId(voucherId);
    save(voucherOrder);

    // 8. 返回订单id
    return Result.ok(orderId);
}
```

<img src="%E9%A1%B9%E7%9B%AE.assets/Screen%20Shot%202023-09-04%20at%203.15.01%20PM.png" alt="Screen Shot 2023-09-04 at 3.15.01 PM" style="zoom:33%;" />



- **集群模式下 → 不同的JVM → 不同的锁监视器**
- **`synchronized` 只能保证单个 JVM 内部多个线程之间的互斥，没有办法保证集群模式下多个 JVM 之间线程之间的互斥**

<img src="%E9%A1%B9%E7%9B%AE.assets/Screen%20Shot%202023-09-04%20at%203.15.41%20PM.png" alt="Screen Shot 2023-09-04 at 3.15.41 PM" style="zoom:33%;" />

+ **分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。**

+ **`setnx` → 只有数据不存在的时候才能set成功**
  + **利用key的过期机制解决安全性问题**

<img src="%E9%A1%B9%E7%9B%AE.assets/Screen%20Shot%202023-09-04%20at%203.17.00%20PM.png" alt="Screen Shot 2023-09-04 at 3.17.00 PM" style="zoom:33%;" />

```java
package com.hmdp.utils;

public interface ILock {
    /**
     * 尝试获取锁
     * @param timeoutSec 锁持有的超时时间，过期后自动释放
     * @return true代表获取锁成功，false代表获取锁失败
     */
    boolean tryLock(long timeoutSec);

    /**
     * 释放锁
     */
    void unlock();
}
```

```java
@Override
public Result seckillVoucher(Long voucherId) {
    // 1. 查询优惠券
    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);

    // 2. 判断秒杀是否开始
    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {
        // 尚未开始
        return Result.fail("秒杀尚未开始！");
    }

    // 3. 判断秒杀是否结束
    if (voucher.getEndTime().isBefore(LocalDateTime.now())) {
        // 已经结束
        return Result.fail("秒杀尚未开始！");
    }

    // 4. 判断库存是否充足
    if (voucher.getStock() < 1) {
        // 库存不足
        return Result.fail("库存不足！");
    }

    Long userId = UserHolder.getUser().getId();
    // 创建锁对象
     SimpleRedisLock lock = new SimpleRedisLock("order:" + userId, stringRedisTemplate); // 锁定的范围是用户id，锁定范围较小，并发度较高
  	// public class SimpleRedisLock implements ILock
  
    // RLock lock = redissonClient.getLock("lock:order:" + userId);
    // 获取锁
    boolean isLock = lock.tryLock(1200);
    // 判断是否获取锁成功
    if (!isLock) {
        // 获取锁失败，返回错误或重试
        return Result.fail("不允许重复下单");
    }
    try {
        // 获取代理对象(事务)
        IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
        return proxy.createVoucherOrder(voucherId);
    } finally {
        // 释放锁
        lock.unlock();
    }
}
```

<img src="%E9%A1%B9%E7%9B%AE.assets/Screen%20Shot%202023-09-04%20at%203.19.14%20PM.png" alt="Screen Shot 2023-09-04 at 3.19.14 PM" style="zoom:33%;" />

+ **防止锁误删：解决问题的关键 → 在释放锁的时候做一个判断**

1. **在获取锁时存入线程标示（可以用UUID表示）**
2. **在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致**
   + **如果一致则释放锁**
   + **如果不一致则不释放锁**

```java
private String name; // 业务的名称、锁的名称
private static final String KEY_PREFIX = "lock:"; // 锁的前缀
private static final String ID_PREFIX = UUID.randomUUID().toString(true) + "-";

@Override
public boolean tryLock(long timeoutSec) {
    // 获取线程标识
    String threadId = ID_PREFIX + Thread.currentThread().getId();

    // 获取锁
    Boolean success = stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);
    // Redis 指令中，NX -> 互斥 EX -> 设置超时时间
    // NX -> setIfAbsent EX -> timeout参数
    return Boolean.TRUE.equals(success); // 自动拆箱要注意空指针情况
}

@Override
public void unlock() {
    // 获取线程标识
    String threadId = ID_PREFIX + Thread.currentThread().getId();

    // 获取锁中标识
    String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);

    // 判断标识是否一致
    if (threadId.equals(id)) {
        // 释放锁
        stringRedisTemplate.delete(KEY_PREFIX + name);
    }
}
```

<img src="%E9%A1%B9%E7%9B%AE.assets/Screen%20Shot%202023-09-04%20at%203.29.55%20PM.png" alt="Screen Shot 2023-09-04 at 3.29.55 PM" style="zoom:33%;" />

+ **解决 → 锁的判断和释放必须是原子性操作**
+ **Lua脚本 → 确保多条命令执行时的原子性**

```java
private static final DefaultRedisScript<Long> UNLOCK_SCRIPT; // 返回值 -> Long

static { // 在静态代码块中进行初始化
    UNLOCK_SCRIPT = new DefaultRedisScript<>();
    UNLOCK_SCRIPT.setLocation(new ClassPathResource("unlock.lua"));
    UNLOCK_SCRIPT.setResultType(Long.class);
}

@Override
public void unlock() {
    // 调用lua脚本
    stringRedisTemplate.execute(
            UNLOCK_SCRIPT,
            Collections.singletonList(KEY_PREFIX + name),
            ID_PREFIX + Thread.currentThread().getId()
            );
}
```

**基于Redis的分布式锁实现思路：**

+ **利用set nx ex获取锁，并设置过期时间，保存线程标示**
  + **利用set nx满足互斥性**
  + **利用set ex保证故障时锁依然能释放，避免死锁，提高安全性；兜底方案，防止服务宕机导致锁无法释放**
+ **释放锁时先判断线程标示是否与自己一致，一致则删除锁**



#### 使用 Redis 的 zSet 数据结构实现了点赞排行榜功能，使用 Set 数据结构实现关注、共同关注功能

##### 点赞排行榜

```java
// 点赞功能
@Override
public Result likeBlog(Long id) { 
    // 1. 获取当前登录用户
    Long userId = UserHolder.getUser().getId();

    // 2. 判断当前登录用户是否已经点赞
    String key = "blog:liked:" + id;
    Double score = stringRedisTemplate.opsForZSet().score(key, userId.toString());

    if (score == null) {
        // 3 如果未点赞，可以点赞
        // 3.1 数据库点赞数 + 1
        boolean isSuccess = update().setSql("liked = liked + 1").eq("id", id).update();
        // 3.2 保存用户到Redis的set集合 zadd key value score
        if (isSuccess) {
//                stringRedisTemplate.opsForSet().add(key, userId.toString());
            stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());
        }
    } else {
        // 4. 如果已点赞，取消点赞
        // 4.1 数据库点赞数 - 1
        boolean isSuccess = update().setSql("liked = liked - 1").eq("id", id).update();
        // 4.2 把用户从Redis的set集合移除
        if (isSuccess) {
//                stringRedisTemplate.opsForSet().remove(key, userId.toString());
            stringRedisTemplate.opsForZSet().remove(key, userId.toString());
        }
    }

    return Result.ok();
}
```

```java
// 点赞排行榜
@Override
public Result queryBlogLikes(Long id) {
    String key = BLOG_LIKED_KEY + id; // "blog:liked:"
    // 1. 查询top5的点赞用户 zrange key 0 4
    Set<String> top5 = stringRedisTemplate.opsForZSet().range(key, 0 ,4);

    if (top5 == null || top5.isEmpty()) {
        return Result.ok(Collections.emptyList());
    }

    // 2. 解析出其中的用户id
    List<Long> ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());

    // 3. 根据用户id查询用户
    String idStr = StrUtil.join(",", ids);
    List<UserDTO> userDTOS = userService.query()
            .in("id", ids)
            .last("ORDER BY FIELD(id, " + idStr + ")")
            .list()
            .stream()
            .map(user -> BeanUtil.copyProperties(user, UserDTO.class))
            .collect(Collectors.toList());

    // 4. 返回
    return Result.ok(userDTOS);
}
```



##### 关注、共同关注

```java
@Override
public Result follow(Long followUserId, boolean isFollow) {
    // 获取登录用户
    Long userId = UserHolder.getUser().getId();
    /**
     * followId -> 被关注用户id
     */
    String key = "follows:" + userId;
    // 1. 判断到底是关注还是取关
    if (isFollow) {
        // 2. 关注，新增数据
        Follow follow = new Follow();
        follow.setUserId(userId);
        follow.setFollowUserId(followUserId);
        boolean isSuccess = save(follow);
        if (isSuccess) {
            // 把关注用户的id，放入redis的set集合 sadd userId followUserId
            stringRedisTemplate.opsForSet().add(key, followUserId.toString());
        }
    } else {
        // 3. 取关，删除 delete from tb_follow where user_id = ? and follow_user_id = ?
        boolean isSuccess = remove(new QueryWrapper<Follow>()
                .eq("user_id", userId).eq("follow_user_id", followUserId));
        // 把关注用户的id从redis集合中移除
        if (isSuccess) {
            stringRedisTemplate.opsForSet().remove(key, followUserId.toString());
        }
    }
    return Result.ok();
}

@Override
public Result isFollow(Long followUserId) {
    // 做一次查询判断是否存在

    // 1. 获取登录用户
    Long userId = UserHolder.getUser().getId();

    // 2. 查询是否关注 select count(*) from tb_follow where user_id = ? and follow_user_id = ?
    Integer count = query().eq("user_id", userId).eq("follow_user_id", followUserId).count();

    // 3. 判断

    return Result.ok(count > 0);
}
```

```java
@Override
public Result followCommons(Long id) {
    // 1. 获取当前用户
    Long userId = UserHolder.getUser().getId();
    String key = "follows:" + userId;

    // 2. 求交集
    String Key2 = "follows:" + id;
    Set<String> intersect = stringRedisTemplate.opsForSet().intersect(key, Key2);

    if (intersect == null || intersect.isEmpty()) {
        //  无交集
        return Result.ok(Collections.emptyList());
    }

    // 3. 解析id集合
    List<Long> ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());

    // 4. 查询用户
    List<UserDTO> users = userService.listByIds(ids)
            .stream()
            .map(user -> BeanUtil.copyProperties(user, UserDTO.class))
            .collect(Collectors.toList());
    return Result.ok(users);
}
```







#### 基于 Cache Aside 模式解决数据库与缓存的一致性问题

**Cache Aside Pattern：更新数据库的同时更新缓存**

**如果在更新数据库的期间没有人执行查询操作，那么在这个阶段更新缓存的操作都是无效写操作，所以应该删除缓存**

```java
@Override
@Transactional
public Result update(Shop shop) {
    Long id = shop.getId();
    if (id == null) {
        return Result.fail("店铺id不能为空");
    }
    // 1. 更新数据库
    updateById(shop);

    // 2. 删除缓存
    stringRedisTemplate.delete(CACHE_SHOP_KEY + id);

    return Result.ok();
}
```

