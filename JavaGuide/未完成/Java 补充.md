#### lambda 表达式

**在Java 8中引入，用来简化函数式接口的匿名内部类的书写(函数式接口：有且仅有一个抽象方法的接口)**

+ **() 里面放形参**

+ **->**

+ **{}里面放方法体**

  

#### Stream 流

**在Java 8中引入，结合了 Lambda 表达式，简化集合、数组的操作**

+ **创建 Stream 流**

  ```java
  List<String> list = Arrays.asList("apple", "banana", "cherry");
  Stream<String> stream = list.stream();
  ```

+ **中间方法**

  ```java
  Stream<String> filteredStream = list.stream().filter(s -> s.startsWith("a"));
  // filter limit前几个 skip跳过几个 distinct去重 map转换数据类型
  ```

+ **终结方法**

  ```java
  long count = list.stream().filter(s -> s.startsWith("a")).count();
  // forEach遍历 count toArray collect收集流中的数据，放到集合中
  ```



#### 反射

**在运行时获取类的成员变量、成员方法和构造方法信息**



#### **序列化与反序列化**

+ **序列化：将对象的状态转换为字节流的过程。需要实现`Serializable`接口**
+ **反序列化：将字节流还原成对象的过程**



#### Java8 新特性

+ **lambda 表达式**
+ **函数式接口**
+ **Stream 流**
+ **接口中的默认方法**



#### 基本数据类型

+ **整数类型**
  + **byte 8位**
  + **short 16位**
  + **int 32位**
  + **long 64 位**
+ **浮点类型**
  + **float 32位**
  + **double 64位**
+ **字符类型**
  + **char 16位**
+ **布尔类型**
  + **boolean**



#### 包装类型

**包装类型用于将基本数据类型封装为对象，可以用于泛型。(集合类只能存储对象而不能存储基本数据类型)**



#### 缓存池

**`new Integer(123)` 与 `Integer.valueOf(123)` 的区别在于：**

- **`new Integer(123)` 每次都会新建一个对象**

- **`Integer.valueOf(123)` 会使用缓存池中的对象，多次调用会取得同一个对象的引用**

  - **编译器会在自动装箱过程调用 valueOf() 方法**

  ```
  Integer m = 123;
  Integer n = 123;
  System.out.println(m == n); // true
  ```

**提供对象重用机制，降低资源消耗**



#### String Pool

**字符串常量池保存着所有字符串字面量，这些字面量在编译时期就确定，同时还可以使用 `String` 的 `intern()` 方法在运行过程将字符串添加到字符串常量池中，字符串常量池提供了字符串对象的重用机制**



#### `new String("abc")`

**使用这种方式一共会创建两个字符串对象**

- **"abc" 属于字符串字面量，因此会在字符串常量池创建一个字符串对象；**
- **使用 new 的方式会在堆中创建一个字符串对象。**



#### `final`

**1. 变量**

**声明变量为常量**

- **对于基本类型，final 使数值不变；**
- **对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。**

**2. 方法**  

**声明方法不能被子类重写。**

**3. 类**  

**声明类不能被继承。**



#### `clone()`

**`clone()` 进行浅拷贝，需要实现 `Cloneable` 接口**

+ **浅拷贝：拷贝对象和原始对象的引用类型引用同一个对象**
+ **深拷贝：拷贝对象和原始对象的引用类型引用不同对象**



#### **访问权限修饰符**

+ **`public`：可以从任何地方访问**
+ **`private`成员只能在其所属的类中访问**
+ **`protected`成员对于所属包内的其他类和子类可见**



#### 抽象类与接口的区别

+ **子类继承抽象类时，使用 `extends` 关键字。子类实现接口时，使用 `implements` 关键字**

+ **一个类只能继承一个父类，但可以实现多个接口**
+ **抽象类通常用于定义一组相关类的通用行为，而接口用于定义不相关类的共享行为**





### super

- **调用父类的构造方法**
- **访问父类的方法或字段**



### 面向对象











### 重写发生在运行期&重载发生在编译期

重写发生在运行时，这是因为在运行时，Java虚拟机会根据对象的实际类型来确定应该调用哪个方法。这种动态绑定使得程序能够根据实际的对象类型来执行相应的方法，实现了多态性。重写是面向对象编程中的一个核心概念。

重载的目的是为了提供更多的灵活性和方便性，使得同一个方法名可以根据不同的参数类型和数量执行不同的操作。重载发生在编译时，这是因为编译器会根据方法调用时提供的参数类型和数量来选择最匹配的方法。编译器在编译时会根据方法的签名（包括方法名、参数列表和返回类型）来确定调用哪个方法。

总结起来，重写是在运行时根据对象的实际类型来确定调用的方法，而重载是在编译时根据方法调用时提供的参数类型和数量来确定调用的方法。重写实现了多态性，而重载提供了更灵活的方法调用方式。





在Java中，类的成员变量（实例变量）在对象创建时进行初始化。成员变量是在类中声明的变量，每个类的实例（对象）都有一份独立的成员变量副本。

类的成员变量可以在声明时进行初始化，也可以在构造函数中进行初始化。当对象被创建时，它的成员变量会被自动初始化为对应类型的默认值（例如，`int`为0，`boolean`为`false`，对象引用为`null`）。然后，如果在声明时没有进行初始化，或者在构造函数中进行了其他的初始化操作，成员变量的值将会被相应的赋值。

以下是类成员变量的初始化时机示例：

1. 在声明时初始化：

```java
public class MyClass {
    private int x = 10; // 成员变量x在声明时初始化为10
    private String name = "John"; // 成员变量name在声明时初始化为"John"
}
```

2. 在构造函数中初始化：

```java
public class MyClass {
    private int x; // 成员变量x声明但未初始化

    public MyClass(int xValue) {
        x = xValue; // 在构造函数中初始化成员变量x
    }
}
```

请注意，每个对象都有自己独立的成员变量副本，它们的值可以根据对象的不同而不同。当创建一个新的对象时，Java会为每个成员变量分配内存并进行初始化。****



### 
